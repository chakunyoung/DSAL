LIS = [조건을 체크하고 count + 1]

(띄엄띄엄 골라서 최고 길이의 증가 수열) -> 사용할 것을 선택하는 문제
시간 복잡도 O(n^2)

1 4 2 6 10 7 2
o   o o    o    => 4

현재 자신의 값보다 이전 값이 작다면 연결할 수 있음 ( 과거 dp + 1[자신] )

[2중 반복문 사용]
idx 를 늘리며, 이전 dp 를 확인한다.

if( 과거 값과 자신의 값이 유효하면 )
dp[i] = max(dp[i], dp[j+1])
// count[i]는 계속 갱신됨
// count[i]는 이미 + 1 된 상태라서 그냥 count[i]

ex) j가 4번일 때 count 2였다면 (자신포함 + 1) 햇음
// dp 과거를 쓰면서, 자신도 유효하면 + 1
// dp 과거와 충돌로 자신이 유효하지 않으면 그냥 원래 자기꺼 // 둘중 큰거 사용

근데 5번을 확인할 때 똑같이 2 이면 그냥 자신 꺼 사용.
" j를 앞에서 부터 자기까지 오며, 자신을 계속 update 함 "





